//
//  SupplementPlan.swift
//  HealthOptimizer
//
//  Supplement recommendation models
//

import Foundation

// MARK: - Supplement Plan

/// Complete supplementation plan generated by AI
struct SupplementPlan: Identifiable, Sendable, nonisolated Codable {
  var id: UUID
  var supplements: [SupplementRecommendation]
  var generalGuidelines: String
  var warnings: [String]
  var interactionNotes: [String]
  var createdAt: Date

  enum CodingKeys: String, CodingKey {
    case id, supplements, generalGuidelines, warnings, interactionNotes, createdAt
  }

  init(
    id: UUID = UUID(),
    supplements: [SupplementRecommendation] = [],
    generalGuidelines: String = "",
    warnings: [String] = [],
    interactionNotes: [String] = [],
    createdAt: Date = Date()
  ) {
    self.id = id
    self.supplements = supplements
    self.generalGuidelines = generalGuidelines
    self.warnings = warnings
    self.interactionNotes = interactionNotes
    self.createdAt = createdAt
  }

  // Custom decoder to handle flexible types from AI
  init(from decoder: Decoder) throws {
    let container = try decoder.container(keyedBy: CodingKeys.self)

    id = AIJSONCoding.decodeUUID(from: container, forKey: .id)
    supplements = try container.decodeIfPresent([SupplementRecommendation].self, forKey: .supplements) ?? []
    generalGuidelines = try container.decodeIfPresent(String.self, forKey: .generalGuidelines) ?? ""

    // Handle warnings as array or single string
    if let warningsArray = try? container.decode([String].self, forKey: .warnings) {
      warnings = warningsArray
    } else if let warningsString = try? container.decode(String.self, forKey: .warnings) {
      warnings = [warningsString]
    } else {
      warnings = []
    }

    // Handle interactionNotes as array or single string
    if let notesArray = try? container.decode([String].self, forKey: .interactionNotes) {
      interactionNotes = notesArray
    } else if let notesString = try? container.decode(String.self, forKey: .interactionNotes) {
      interactionNotes = [notesString]
    } else {
      interactionNotes = []
    }

    createdAt = try container.decodeIfPresent(Date.self, forKey: .createdAt) ?? Date()
  }

  /// Group supplements by timing for display
  var supplementsByTiming: [SupplementTiming: [SupplementRecommendation]] {
    Dictionary(grouping: supplements) { $0.timing }
  }

  /// Priority supplements (essentials)
  var prioritySupplements: [SupplementRecommendation] {
    supplements.filter { $0.priority == .essential }
  }
}

// MARK: - Supplement Recommendation

/// Individual supplement recommendation
struct SupplementRecommendation: Codable, Identifiable, Sendable {
  var id: UUID
  var name: String
  var alternateNames: [String]  // Common brand names or forms
  var dosage: String
  var unit: String
  var timing: SupplementTiming
  var frequency: SupplementFrequency
  var withFood: Bool
  var priority: SupplementPriority
  var reasoning: String
  var scientificBacking: String
  var benefits: [String]
  var potentialSideEffects: [String]
  var interactions: [String]
  var contraindications: [String]
  var qualityNotes: String?  // What to look for when purchasing
  var estimatedMonthlyCost: String?  // Price range
  var duration: String?  // How long to take (if not indefinite)

  init(
    id: UUID = UUID(),
    name: String,
    alternateNames: [String] = [],
    dosage: String,
    unit: String = "mg",
    timing: SupplementTiming = .morning,
    frequency: SupplementFrequency = .daily,
    withFood: Bool = true,
    priority: SupplementPriority = .recommended,
    reasoning: String = "",
    scientificBacking: String = "",
    benefits: [String] = [],
    potentialSideEffects: [String] = [],
    interactions: [String] = [],
    contraindications: [String] = [],
    qualityNotes: String? = nil,
    estimatedMonthlyCost: String? = nil,
    duration: String? = nil
  ) {
    self.id = id
    self.name = name
    self.alternateNames = alternateNames
    self.dosage = dosage
    self.unit = unit
    self.timing = timing
    self.frequency = frequency
    self.withFood = withFood
    self.priority = priority
    self.reasoning = reasoning
    self.scientificBacking = scientificBacking
    self.benefits = benefits
    self.potentialSideEffects = potentialSideEffects
    self.interactions = interactions
    self.contraindications = contraindications
    self.qualityNotes = qualityNotes
    self.estimatedMonthlyCost = estimatedMonthlyCost
    self.duration = duration
  }

  // Custom decoding to handle flexible types from AI
  init(from decoder: Decoder) throws {
    let container = try decoder.container(keyedBy: CodingKeys.self)

    id = AIJSONCoding.decodeUUID(from: container, forKey: .id)
    name = try container.decode(String.self, forKey: .name)
    alternateNames = AIJSONCoding.decodeStringArray(from: container, forKey: CodingKeys.alternateNames)
    dosage = AIJSONCoding.decodeString(from: container, forKey: CodingKeys.dosage)
    unit = try container.decodeIfPresent(String.self, forKey: .unit) ?? "mg"
    timing = try container.decodeIfPresent(SupplementTiming.self, forKey: .timing) ?? .morning
    frequency = try container.decodeIfPresent(SupplementFrequency.self, forKey: .frequency) ?? .daily
    withFood = try container.decodeIfPresent(Bool.self, forKey: .withFood) ?? true
    priority = try container.decodeIfPresent(SupplementPriority.self, forKey: .priority) ?? .recommended
    reasoning = try container.decodeIfPresent(String.self, forKey: .reasoning) ?? ""
    scientificBacking = try container.decodeIfPresent(String.self, forKey: .scientificBacking) ?? ""
    benefits = AIJSONCoding.decodeStringArray(from: container, forKey: CodingKeys.benefits)
    potentialSideEffects = AIJSONCoding.decodeStringArray(from: container, forKey: CodingKeys.potentialSideEffects)
    interactions = AIJSONCoding.decodeStringArray(from: container, forKey: CodingKeys.interactions)
    contraindications = AIJSONCoding.decodeStringArray(from: container, forKey: CodingKeys.contraindications)
    qualityNotes = try container.decodeIfPresent(String.self, forKey: .qualityNotes)
    estimatedMonthlyCost = try container.decodeIfPresent(String.self, forKey: .estimatedMonthlyCost)
    duration = try container.decodeIfPresent(String.self, forKey: .duration)
  }

  /// Full dosage display string
  var dosageDisplay: String {
    "\(dosage) \(unit)"
  }

  /// Complete timing description
  var timingDescription: String {
    var desc = timing.rawValue
    if withFood {
      desc += " with food"
    } else {
      desc += " on empty stomach"
    }
    return desc
  }
}

// MARK: - Supplement Timing

/// When to take supplements
nonisolated enum SupplementTiming: String, Codable, CaseIterable, Identifiable, Sendable {
  case morning = "Morning"
  case midday = "Midday"
  case afternoon = "Afternoon"
  case evening = "Evening"
  case beforeBed = "Before Bed"
  case preWorkout = "Pre-Workout"
  case postWorkout = "Post-Workout"
  case withMeals = "With Meals"
  case betweenMeals = "Between Meals"
  case asNeeded = "As Needed"

  var id: String { rawValue }

  var icon: String {
    switch self {
    case .morning: return "sunrise.fill"
    case .midday: return "sun.max.fill"
    case .afternoon: return "sun.haze.fill"
    case .evening: return "sunset.fill"
    case .beforeBed: return "moon.fill"
    case .preWorkout: return "figure.run"
    case .postWorkout: return "figure.cooldown"
    case .withMeals: return "fork.knife"
    case .betweenMeals: return "clock.fill"
    case .asNeeded: return "questionmark.circle.fill"
    }
  }

  /// Suggested time of day
  var suggestedTime: String {
    switch self {
    case .morning: return "6:00 - 8:00 AM"
    case .midday: return "12:00 - 1:00 PM"
    case .afternoon: return "3:00 - 4:00 PM"
    case .evening: return "6:00 - 7:00 PM"
    case .beforeBed: return "9:00 - 10:00 PM"
    case .preWorkout: return "30-60 min before exercise"
    case .postWorkout: return "Within 30 min after exercise"
    case .withMeals: return "During meals"
    case .betweenMeals: return "2-3 hours after eating"
    case .asNeeded: return "When symptoms occur"
    }
  }

  init(from decoder: Decoder) throws {
    let container = try decoder.singleValueContainer()
    let raw = try container.decode(String.self)
    let normalized = raw.trimmingCharacters(in: .whitespacesAndNewlines).lowercased()

    if let exact = SupplementTiming(rawValue: raw) {
      self = exact
      return
    }

    if normalized.contains("morning") || normalized.contains("am") {
      self = .morning
    } else if normalized.contains("midday") || normalized.contains("noon") {
      self = .midday
    } else if normalized.contains("afternoon") {
      self = .afternoon
    } else if normalized.contains("evening") || normalized.contains("dinner") {
      self = .evening
    } else if normalized.contains("before") && normalized.contains("bed")
      || normalized.contains("bedtime")
      || normalized.contains("night")
    {
      self = .beforeBed
    } else if normalized.contains("pre") && normalized.contains("workout") {
      self = .preWorkout
    } else if normalized.contains("post") && normalized.contains("workout") {
      self = .postWorkout
    } else if normalized.contains("with") && normalized.contains("meal") {
      self = .withMeals
    } else if normalized.contains("between") && normalized.contains("meal") {
      self = .betweenMeals
    } else if normalized.contains("as needed") || normalized.contains("needed") || normalized.contains("prn") {
      self = .asNeeded
    } else {
      self = .morning
    }
  }

  func encode(to encoder: Encoder) throws {
    var container = encoder.singleValueContainer()
    try container.encode(rawValue)
  }
}

// MARK: - Supplement Frequency

/// How often to take a supplement
nonisolated enum SupplementFrequency: String, Codable, CaseIterable, Identifiable, Sendable {
  case daily = "Daily"
  case twiceDaily = "Twice Daily"
  case threeTimesDaily = "Three Times Daily"
  case everyOtherDay = "Every Other Day"
  case weekly = "Weekly"
  case asNeeded = "As Needed"
  case cyclic = "Cyclic (see notes)"

  var id: String { rawValue }

  init(from decoder: Decoder) throws {
    let container = try decoder.singleValueContainer()
    let raw = try container.decode(String.self)
    let normalized = raw.trimmingCharacters(in: .whitespacesAndNewlines).lowercased()

    if let exact = SupplementFrequency(rawValue: raw) {
      self = exact
      return
    }

    if normalized == "daily" || normalized.contains("once") && normalized.contains("day") {
      self = .daily
    } else if normalized.contains("twice") || normalized.contains("2x") || normalized.contains("two times") {
      self = .twiceDaily
    } else if normalized.contains("three") || normalized.contains("3x") || normalized.contains("three times") {
      self = .threeTimesDaily
    } else if normalized.contains("every other") || normalized.contains("alternate day") {
      self = .everyOtherDay
    } else if normalized.contains("weekly") || normalized.contains("once a week") {
      self = .weekly
    } else if normalized.contains("as needed") || normalized.contains("needed") || normalized.contains("prn") {
      self = .asNeeded
    } else if normalized.contains("cyclic") || normalized.contains("cycle") {
      self = .cyclic
    } else {
      self = .daily
    }
  }

  func encode(to encoder: Encoder) throws {
    var container = encoder.singleValueContainer()
    try container.encode(rawValue)
  }
}

// MARK: - Supplement Priority

/// Priority level for supplement recommendations
nonisolated enum SupplementPriority: String, Codable, CaseIterable, Identifiable, Sendable {
  case essential = "Essential"
  case recommended = "Highly Recommended"
  case beneficial = "Beneficial"
  case optional = "Optional/Consider"

  var id: String { rawValue }

  var color: String {
    switch self {
    case .essential: return "red"
    case .recommended: return "orange"
    case .beneficial: return "blue"
    case .optional: return "gray"
    }
  }

  var sortOrder: Int {
    switch self {
    case .essential: return 0
    case .recommended: return 1
    case .beneficial: return 2
    case .optional: return 3
    }
  }

  init(from decoder: Decoder) throws {
    let container = try decoder.singleValueContainer()
    let raw = try container.decode(String.self)
    let normalized = raw.trimmingCharacters(in: .whitespacesAndNewlines).lowercased()

    if let exact = SupplementPriority(rawValue: raw) {
      self = exact
      return
    }

    if normalized.contains("essential") || normalized.contains("must") {
      self = .essential
    } else if normalized.contains("high") && normalized.contains("recommend") || normalized.contains("recommended") {
      self = .recommended
    } else if normalized.contains("beneficial") || normalized.contains("helpful") {
      self = .beneficial
    } else if normalized.contains("optional") || normalized.contains("consider") {
      self = .optional
    } else {
      self = .recommended
    }
  }

  func encode(to encoder: Encoder) throws {
    var container = encoder.singleValueContainer()
    try container.encode(rawValue)
  }
}

// MARK: - Sample Data

extension SupplementPlan {
  /// Sample supplement plan for previews
  static var sample: SupplementPlan {
    SupplementPlan(
      supplements: [
        SupplementRecommendation(
          name: "Vitamin D3",
          alternateNames: ["Cholecalciferol"],
          dosage: "5000",
          unit: "IU",
          timing: .morning,
          withFood: true,
          priority: .essential,
          reasoning:
            "Most adults are deficient, especially with indoor lifestyle. Critical for immune function, bone health, and mood.",
          scientificBacking:
            "Multiple meta-analyses show benefits for immunity, bone health, and mood. Blood levels of 40-60 ng/mL are optimal.",
          benefits: ["Immune support", "Bone health", "Mood regulation", "Muscle function"],
          potentialSideEffects: ["Rare at recommended doses", "Hypercalcemia at very high doses"],
          qualityNotes: "Look for D3 (not D2), ideally with K2 for synergy",
          estimatedMonthlyCost: "$10-20"
        ),
        SupplementRecommendation(
          name: "Magnesium Glycinate",
          alternateNames: ["Magnesium Bisglycinate"],
          dosage: "400",
          unit: "mg",
          timing: .beforeBed,
          withFood: false,
          priority: .essential,
          reasoning:
            "Supports sleep quality, stress management, and muscle recovery. Most diets are deficient.",
          scientificBacking:
            "Well-absorbed form with research supporting sleep and anxiety benefits.",
          benefits: ["Better sleep", "Reduced stress", "Muscle relaxation", "Heart health"],
          potentialSideEffects: ["Loose stools at high doses"],
          qualityNotes: "Glycinate form is best for sleep; avoid oxide form (poor absorption)",
          estimatedMonthlyCost: "$15-25"
        ),
        SupplementRecommendation(
          name: "Omega-3 Fish Oil",
          alternateNames: ["EPA/DHA", "Fish Oil"],
          dosage: "2000",
          unit: "mg EPA+DHA",
          timing: .withMeals,
          withFood: true,
          priority: .recommended,
          reasoning: "Anti-inflammatory support for heart, brain, and joint health.",
          scientificBacking:
            "Extensive research on cardiovascular benefits and inflammation reduction.",
          benefits: ["Heart health", "Brain function", "Joint support", "Inflammation reduction"],
          potentialSideEffects: [
            "Fish burps (use enteric-coated)", "Blood thinning at high doses",
          ],
          interactions: ["Blood thinners - consult doctor"],
          qualityNotes:
            "Look for triglyceride form, third-party tested for purity (IFOS certified)",
          estimatedMonthlyCost: "$20-40"
        ),
      ],
      generalGuidelines:
        "Start with essential supplements first, then add others gradually. Take with meals unless otherwise noted. Stay consistent for best results.",
      warnings: [
        "Always consult your healthcare provider before starting new supplements, especially with existing conditions or medications."
      ],
      interactionNotes: ["No significant interactions identified with your current medications."]
    )
  }
}
